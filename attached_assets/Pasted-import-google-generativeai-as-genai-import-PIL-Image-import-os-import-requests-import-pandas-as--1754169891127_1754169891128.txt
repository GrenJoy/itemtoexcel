import google.generativeai as genai
import PIL.Image
import os
import requests
import pandas as pd
from datetime import datetime
import re
import json
import time
from typing import List, Dict, Optional
from collections import Counter # Импортируем Counter для подсчета дубликатов

class WarframeInventoryChecker:
    def __init__(self, gemini_api_key: str):
        """Инициализация системы проверки инвентаря Warframe."""
        genai.configure(api_key=gemini_api_key)
        self.model = genai.GenerativeModel('gemini-1.5-flash-latest')
        
        self.wfm_base_url = "https://api.warframe.market/v2"
        self.headers = {
            'Platform': 'pc', 'Language': 'ru', 'User-Agent': 'Warframe-Inventory-Checker/Updatable-v1'
        }
        
        self.items_cache = {}
        self.load_items_cache()

    def normalize_string(self, text: str) -> str:
        """Приводит строку к единому виду: нижний регистр, замена ё->е, убирает лишние пробелы."""
        if not isinstance(text, str): return ""
        cleaned_text = text.lower().replace('ё', 'е').strip()
        cleaned_text = re.sub(r'\s*:\s*', ': ', cleaned_text)
        cleaned_text = re.sub(r'\s+', ' ', cleaned_text)
        return cleaned_text

    def load_items_cache(self):
        """Загружаем список всех предметов из WFM API (используя v2)."""
        try:
            print("Загружаем справочник предметов из Warframe Market...")
            response = requests.get(f"{self.wfm_base_url}/items", headers=self.headers, timeout=30)
            response.raise_for_status()
            items_list = response.json().get('data', [])
            for item in items_list:
                item_name_ru = item.get('i18n', {}).get('ru', {}).get('name')
                if item_name_ru:
                    self.items_cache[self.normalize_string(item_name_ru)] = item
            print(f"Загрузка завершена. В кэше {len(self.items_cache)} уникальных записей.")
        except Exception as e:
            print(f"Критическая ошибка при загрузке справочника предметов: {e}")

    def analyze_inventory_screenshot(self, image_path: str) -> List[str]:
        """Анализ скриншота с помощью Gemini с вашим последним промптом."""
        try:
            print(f"\nАнализируем изображение: {os.path.basename(image_path)}")
            img = PIL.Image.open(image_path)
            
            # --- ВАШ УЛУЧШЕННЫЙ ПРОМПТ ---
            prompt = """
            Твоя задача - точно скопировать названия предметов из списка на скриншоте из игры Warframe.
            
            ПРАВИЛА:
            1.  Выписывай каждый предмет НА ОТДЕЛЬНОЙ СТРОКЕ.
            2.  Если строка начинается со слова "ЧЕРТЁЖ:", ОБЯЗАТЕЛЬНО в ответе удали слово "ЧЕРТЕЖ:" в начале но добавь - "(Чертеж)" в конце, например было ЧЕРТЕЖ: Лавос Прайм: Система, а станет Лавос Прайм: Система (Чертеж).
            3.  Не добавляй ничего от себя. Просто скопируй текст как можно точнее.
            
            ПРИМЕР ОЖИДАЕМОГО ВЫВОДА:
            Наутилус Прайм: Панцирь
            Наутилус Прайм: Система
            Севагот Прайм: Система (Чертеж)
            
            Начинай копирование:
            """
            response = self.model.generate_content([prompt, img])
            items_text = response.text.strip()
            items_list = [item.strip() for item in items_text.split('\n') if item.strip()]
            print(f"  > Gemini распознал {len(items_list)} строк.")
            return items_list
        except Exception as e:
            print(f"Ошибка при анализе изображения: {e}")
            return []

    def find_item_slug(self, raw_item_name: str) -> Optional[str]:
        """Ищет slug по уже отформатированному названию."""
        # Поскольку Gemini теперь сам форматирует название, поиск упрощается
        normalized_name = self.normalize_string(raw_item_name)
        
        print(f"Обрабатываем: '{raw_item_name}'. Ищем в кэше: '{normalized_name}'")
        
        if normalized_name in self.items_cache:
            item_data = self.items_cache[normalized_name]
            item_slug = item_data.get("slug")
            print(f"  ✅ НАЙДЕН: '{normalized_name}' -> slug: '{item_slug}'")
            return item_slug
        else:
            print(f"  ❌ НЕ НАЙДЕН.")
            return None

    def get_item_prices(self, item_slug: str) -> Dict:
        """Получение цен на предмет по его slug."""
        url = f"{self.wfm_base_url}/orders/item/{item_slug}/top"
        print(f"  > Запрашиваем цены по URL: {url}")
        try:
            response = requests.get(url, headers=self.headers, timeout=15)
            response.raise_for_status() 
            data = response.json().get('data', {})
            sell_orders = data.get('sell', [])
            buy_orders = data.get('buy', [])
            sell_prices = [order['platinum'] for order in sell_orders]
            buy_prices = [order['platinum'] for order in buy_orders]
            print(f"  > ✅ Успех! Найдено цен: Продажа - {len(sell_prices)}, Покупка - {len(buy_prices)}")
            return {
                'buy_prices': buy_prices, 'sell_prices': sell_prices,
                'avg_buy': round(sum(buy_prices) / len(buy_prices), 2) if buy_prices else 0,
                'avg_sell': round(sum(sell_prices) / len(sell_prices), 2) if sell_prices else 0
            }
        except Exception as e:
            print(f"  ⚠️ Ошибка при получении цен для {item_slug}: {e}")
        time.sleep(0.5) 
        return {'buy_prices': [], 'sell_prices': [], 'avg_buy': 0, 'avg_sell': 0}

    def process_and_update_inventory(self, image_paths: List[str], inventory_file_path: str) -> pd.DataFrame:
        """
        НОВАЯ УЛУЧШЕННАЯ ЛОГИКА:
        1. Загружает существующий Excel, если он есть.
        2. Анализирует все изображения и подсчитывает количество каждого предмета.
        3. Обновляет или добавляет предметы в DataFrame.
        4. Возвращает итоговый DataFrame для сохранения.
        """
        # 1. Загрузка существующего файла
        if os.path.exists(inventory_file_path):
            print(f"\nНайден существующий инвентарь: {inventory_file_path}. Загружаем для обновления...")
            try:
                # Используем 'Название' как индекс для быстрого доступа
                df = pd.read_excel(inventory_file_path).set_index('Название')
                if 'Количество' not in df.columns:
                    df['Количество'] = 1 # Добавляем колонку, если ее не было
            except Exception as e:
                print(f"  > Ошибка чтения Excel файла, создаем новую таблицу. Ошибка: {e}")
                df = pd.DataFrame(columns=['Название', 'Количество', 'Slug', 'Цены продажи', 'Цены покупки', 'Средняя продажа', 'Средняя покупка', 'Ссылка']).set_index('Название')
        else:
            print(f"\nСуществующий файл '{inventory_file_path}' не найден, будет создан новый.")
            df = pd.DataFrame(columns=['Название', 'Количество', 'Slug', 'Цены продажи', 'Цены покупки', 'Средняя продажа', 'Средняя покупка', 'Ссылка']).set_index('Название')

        # 2. Анализ и подсчет количества
        all_item_names = []
        for image_path in image_paths:
            items = self.analyze_inventory_screenshot(image_path)
            all_item_names.extend(items)
        
        # Используем Counter для элегантного подсчета дубликатов
        item_counts = Counter(all_item_names)
        print(f"\n--- Начинаем обработку для {len(item_counts)} уникальных предметов из новых скриншотов ---")

        # 3. Обновление или добавление предметов
        for item_name, quantity in item_counts.items():
            # Используем нормализованное имя для проверки наличия в DataFrame
            normalized_item_name_for_df_check = self.normalize_string(item_name)

            # Ищем оригинальное название в индексе, т.к. мы его не меняли
            if item_name in df.index:
                # Предмет уже есть - просто увеличиваем количество
                print(f"Обновляем: '{item_name}', добавляем {quantity} шт.")
                df.loc[item_name, 'Количество'] += quantity
            else:
                # Предмета нет - ищем информацию и добавляем как новую строку
                print(f"Добавляем новый предмет: '{item_name}'")
                slug = self.find_item_slug(item_name)
                if slug:
                    prices = self.get_item_prices(slug)
                    new_row = {
                        'Количество': quantity,
                        'Slug': slug,
                        'Цены продажи': ', '.join(map(str, prices['sell_prices'])) or 'Нет',
                        'Цены покупки': ', '.join(map(str, prices['buy_prices'])) or 'Нет',
                        'Средняя продажа': prices['avg_sell'],
                        'Средняя покупка': prices['avg_buy'],
                        'Ссылка': f"https://warframe.market/ru/items/{slug}"
                    }
                else:
                    new_row = {'Количество': quantity, 'Slug': 'НЕ НАЙДЕН', 'Цены продажи': 'N/A', 'Цены покупки': 'N/A', 'Средняя продажа': 0, 'Средняя покупка': 0, 'Ссылка': 'N/A'}
                
                # Добавляем новую строку в DataFrame, используя оригинальное имя как индекс
                df.loc[item_name] = new_row
        
        # Возвращаем DataFrame с сброшенным индексом для сохранения
        return df.reset_index()

def main():
    """Основная функция для запуска программы."""
    # --- НАСТРОЙКИ ---
    api_key = os.environ.get("GEMINI_API_KEY")
    if not api_key:
        api_key = input("Пожалуйста, вставьте ваш API ключ для Gemini и нажмите Enter: ")
    if not api_key: 
        print("API ключ не предоставлен. Выход.")
        return

    # 1. УКАЖИТЕ ПУТЬ К ВАШЕМУ ГЛАВНОМУ ФАЙЛУ ИНВЕНТАРЯ
    # Этот файл будет создаваться или обновляться.
    inventory_file = "мой_полный_инвентарь.xlsx"

    # 2. УКАЖИТЕ ПУТИ К НОВЫМ СКРИНШОТАМ, КОТОРЫЕ НУЖНО ДОБАВИТЬ
    new_screenshots = [
        r"C:\Users\alexu\Desktop\Warframe\items.jpg",
        # r"C:\путь\к\второму\новому_скриншоту.png",
    ]
    
    # --- ЗАПУСК ---
    valid_screenshots = [path for path in new_screenshots if os.path.exists(path)]
    if not valid_screenshots:
        print("!!! ВНИМАНИЕ: Не найдено ни одного файла по указанным путям. Проверьте пути в `new_screenshots`.")
        return

    try:
        # Инициализируем наш чекер
        checker = WarframeInventoryChecker(gemini_api_key=api_key)
        if not checker.items_cache:
            print("Не удалось загрузить справочник предметов. Программа не может продолжить работу.")
            return

        # Запускаем новый процесс обновления
        final_df = checker.process_and_update_inventory(valid_screenshots, inventory_file)

        # Сохраняем итоговый обновленный DataFrame
        # Сначала убедимся, что колонка 'Количество' целочисленная
        final_df['Количество'] = final_df['Количество'].astype(int)
        
        final_df.to_excel(inventory_file, index=False, engine='openpyxl')
        print(f"\n✅ Инвентарь успешно обновлен и сохранен в файл: {os.path.abspath(inventory_file)}")
        
        # Выводим итоговую статистику
        print(f"\n📊 --- ИТОГОВАЯ СТАТИСТИКА ---")
        found_count = len(final_df[final_df['Slug'] != 'НЕ НАЙДЕН'])
        total_count = len(final_df)
        print(f"Всего уникальных предметов в инвентаре: {total_count}")
        print(f"Успешно найдено в базе Warframe.market: {found_count}")
        
        # Рассчитываем общую стоимость, умножая среднюю цену на количество
        total_value = (final_df['Средняя продажа'] * final_df['Количество']).sum()
        print(f"Общая примерная стоимость инвентаря: {total_value:.2f} платины")

    except Exception as e:
        print(f"❌ Произошла непредвиденная критическая ошибка: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()

Вот мой код с логикой. Итак ИИ анализирует названия (внутри него промпт) и дает ответ, потом эти предметы ищутся в базе через Api warframe market и возвращаются название, англ название и ссылка, потом Order это цена, там средняя цена и так далее. Потом создается файл Excel (пример на фото). Я хочу чтобы вся логика скрипта была реализована на Сайте и доступна всем людям. ИТАК ДАЛЬШЕ ВАЖНО - "Я хочу чтобы пользователь мог загрузить пару фоток (бессконечно) ии их проанализирует и будет также создавать Excel с назв, ценой и т.п (пример на скрине) НО если предмет повторяется то просто в столбце "Количество" будет +1 например 2, потом если предмет еще раз найден в базе то 3 и так далее. Дальше Люди трейдятся с игроками каждый день по-этому каждый раз кидать скриншоты трейдов и создавать новые Excel Файлы не релевантно тяжело и запутано по-этому скрипт должен уметь РЕДАКТИРОВАТЬ файл то есть пользователь загрузил Excel файл и к нему ДОБАВИЛ скриншоты, ИИ снова вытащил название, цену и так далее (пример на скрине) и отредактировал Excel файл пользователя добавив туда новые заказы, а если Предмет УЖЕ в файле excel то просто добавляется Количество +1 в соответствующем столбце. 